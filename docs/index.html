<!-- Schéma global
Tu cliques sur un bouton dans le front (index.html).
Le JS envoie une requête (fetch) à ton backend (app.py).
Flask reçoit l’appel sur /ask, /save, ou /pdf.
Flask traite : soit appelle Mistral, soit écrit/relit QR.txt, soit génère PDF.
Réponse envoyée au navigateur, qui met à jour l’UI. -->

<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>QA Minimal</title>
  <style>
    :root { --gap: 12px; --radius: 12px; }
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0; padding: 0; background: #f7f7f8; color: #111;
    }
    header { position: sticky; top: 0; background: #fff; border-bottom: 1px solid #e7e7ea; padding: 12px 16px; z-index: 10; }
    header h1 { margin: 0; font-size: 18px; }

    .container { max-width: 900px; margin: 0 auto; padding: 16px; }

    .toolbar {
      display: grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: var(--gap);
      margin-bottom: 16px;
    }
    button {
      appearance: none; border: 1px solid #d8d8dd; background: #fff; color: #111;
      padding: 10px 12px; border-radius: var(--radius); cursor: pointer; font-weight: 600;
      transition: transform .02s ease, background .2s ease, border-color .2s ease;
    }
    button:hover { background: #fafafa; }
    button:active { transform: translateY(1px); }
    button[disabled] { opacity: .6; cursor: not-allowed; }

    .panel { background: #fff; border: 1px solid #e7e7ea; border-radius: var(--radius); padding: 12px; }

    .chat-area { display: grid; grid-template-rows: 1fr auto; gap: var(--gap); height: 60vh; }

    .messages {
      overflow: auto; padding: 8px; display: flex; flex-direction: column; gap: 8px;
      background: #fcfcfd; border: 1px solid #eee; border-radius: var(--radius);
    }
    .msg { max-width: 80%; padding: 10px 12px; border-radius: 14px; border: 1px solid #e5e7eb; }
    .msg.q { align-self: flex-start; background: #f1f5ff; border-color: #dbe5ff; }
    .msg.a { align-self: flex-end; background: #eef8f0; border-color: #d8f0dc; }
    .meta { font-size: 12px; color: #666; }

    .inputbar { display: grid; grid-template-columns: 1fr auto; gap: var(--gap); align-items: center; }
    .inputbar input[type="text"] {
      width: 100%; padding: 12px 14px; border-radius: var(--radius); border: 1px solid #d8d8dd; font-size: 15px;
    }

    .status { margin-top: 10px; font-size: 14px; color: #555; min-height: 1.2em; }
  </style>
</head>
  <header>
    <h1>Interface Q/R minimale</h1>
  </header>

  <main class="container">
    <section class="toolbar">
      <button id="btnAsk">Poser une question</button>
      <button id="btnSave">Enregistrer mes réponses</button>
      <button id="btnPdf">Générer un PDF</button>
      <button id="btnReset">Réinitialiser</button>
    </section>

    <section class="panel chat-area">
      <div id="messages" class="messages" aria-live="polite"></div>
      <div class="inputbar">
        <input id="answerInput" type="text" placeholder="Votre réponse… (Entrée pour envoyer)" />
        <button id="btnReply">Répondre</button>
      </div>
      <div id="status" class="status"></div>
    </section>
  </main>

  <script>
  //  appeler Render
      const BASE_API = "https://question-answer-07q9.onrender.com"; // ← remplace par ton URL Render
// BASE_API = ton backend Render

    // --- État minimal côté front ---
    /** conversation: tableau d'objets { id, question, answer } */     // ➡️ conversation = mémoire locale des Q/R
    const conversation = [];
    let seq = 0; // identifiant simple croissant // ➡️ seq = compteur de questions

    // --- Helpers DOM ---
    const el = (id) => document.getElementById(id);
    const $messages = el('messages');
    const $status = el('status');
    const $answer = el('answerInput');

    function setBusy(isBusy) {
      el('btnAsk').disabled = isBusy;
      el('btnSave').disabled = isBusy;
      el('btnPdf').disabled = isBusy;
      el('btnReply').disabled = isBusy;
    }

    function scrollToBottom() {
      $messages.scrollTop = $messages.scrollHeight;
    }
// render() : affiche toutes les Q/R dans la zone chat.
    function render() {
      $messages.innerHTML = '';
      for (const item of conversation) {
        const mq = document.createElement('div');
        mq.className = 'msg q';
        mq.innerHTML = `<div><strong>Q${item.id}.</strong> ${escapeHTML(item.question)}</div>`;
        $messages.appendChild(mq);

        if (item.answer && item.answer.trim() !== '') {
          const ma = document.createElement('div');
          ma.className = 'msg a';
          ma.innerHTML = `<div><strong>R${item.id}.</strong> ${escapeHTML(item.answer)}</div>`;
          $messages.appendChild(ma);
        }
      }
      scrollToBottom();
    }
// escapeHTML() : évite les injections HTML.
    function escapeHTML(str='') {
      return str.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
    }
// lastUnanswered() : trouve la dernière question sans réponse.
    function lastUnanswered() {
      for (let i = conversation.length - 1; i >= 0; i--) {
        if (!conversation[i].answer || conversation[i].answer.trim() === '') return conversation[i];
      }
      return null;
    }

    // --- Actions ---
    // askQuestion() : envoie la liste des questions déjà posées → reçoit une nouvelle question → l’ajoute.
    async function askQuestion() {
      setBusy(true); $status.textContent = 'Génération de la question…'; // setBusy(true/false) : active/désactive les boutons pendant les appels.
      try {
        // ① on envoie les questions déjà posées
        const previousQuestions = conversation.map(({question}) => question);

        const res = await fetch(`${BASE_API}/ask`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ previous_questions: previousQuestions })
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json(); // attendu: { question: "..." }

        const qtext = (data && data.question) ? String(data.question) : '(Question non fournie)';
        conversation.push({ id: ++seq, question: qtext, answer: '' });
        render(); $status.textContent = '';
      } catch (err) {
        console.error(err); $status.textContent = 'Erreur lors de la génération de la question.';
      } finally { setBusy(false); }
    }
// sendAnswer() : ajoute une réponse saisie dans conversation.
    function sendAnswer() {
      const txt = $answer.value.trim();
      if (!txt) return;
      const target = lastUnanswered();
      if (target) {
        target.answer = txt;
      } else {
        // Aucun item sans réponse: on attache cette réponse à une nouvelle entrée libre
        conversation.push({ id: ++seq, question: '(Réponse libre sans question)', answer: txt });
      }
      $answer.value = '';
      render();
    }
// saveAll() : envoie toutes les Q/R au backend (/save).
    async function saveAll() {
      setBusy(true); $status.textContent = 'Enregistrement en cours…';
      try {
        const payload = {
          pairs: conversation.map(({id, question, answer}) => ({ id, question, answer })),
          timestamp: new Date().toISOString()
        };
        const res = await fetch(`${BASE_API}/save`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const data = await res.json(); // attendu: { status: "ok" }
        $status.textContent = (data && data.status === 'ok') ? 'Enregistré dans QR.txt' : 'Enregistrement terminé (statut inconnu)';
      } catch (err) {
        console.error(err); $status.textContent = 'Erreur lors de l\'enregistrement.';
      } finally { setBusy(false); }
    }
// generatePdf() : demande au backend un PDF (/pdf) → déclenche un téléchargement.
    async function generatePdf() {
      setBusy(true); $status.textContent = 'Génération du PDF…';
      try {
        const res = await fetch(`${BASE_API}/pdf`);
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'questions_reponses.pdf';
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
        $status.textContent = 'PDF téléchargé';
      } catch (err) {
        console.error(err); $status.textContent = 'Erreur lors de la génération du PDF.';
      } finally { setBusy(false); }
    }
// resetConversation() : remet tout à zéro côté front.
    function resetConversation() {
        conversation.splice(0, conversation.length); // vide le tableau
        seq = 0;                                     // remet l’ID à zéro
        render();                                    // rafraîchit l’affichage
        $status.textContent = "Conversation réinitialisée";
        }

    // --- Événements UI ---
    el('btnAsk').addEventListener('click', askQuestion);
    el('btnSave').addEventListener('click', saveAll);
    el('btnPdf').addEventListener('click', generatePdf);
    el('btnReply').addEventListener('click', sendAnswer);
    $answer.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendAnswer(); }
    });
      // Listeners : chaque bouton appelle la fonction correspondante (btnAsk, btnSave, etc.) du <head>,<main>.
    el('btnReset').addEventListener('click', resetConversation);

    // Astuce: conserver la conversation si on recharge (optionnel)
    try {
      const saved = sessionStorage.getItem('conversation'); //SessionStorage : sauvegarde l’état du chat quand tu recharges la page.
      if (saved) {
        const arr = JSON.parse(saved);
        if (Array.isArray(arr)) { conversation.splice(0, conversation.length, ...arr); seq = conversation.reduce((m, x) => Math.max(m, x.id||0), 0); render(); }
      }
      window.addEventListener('beforeunload', () => sessionStorage.setItem('conversation', JSON.stringify(conversation)));
    } catch {}

  </script>
</body>
</html>
